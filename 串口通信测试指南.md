# 串口双向通信测试指南

## 系统架构

```
上位机(ROS2) ←→ 串口 ←→ 下位机(STM32)
    ↓                       ↓
 控制命令                里程计数据
 (0xA5, 19字节)          (0x5A, Vision_Send_s)
```

### 数据流向

**1. 控制命令 (上位机 → 下位机)**
- `/cmd_vel` → `serial_data_publisher` → `serial_tx_data` → `serial_communication` → **STM32**
- 协议: header=0xA5, vx/vy(m/s), wz(rad/s), timestamp, CRC16
- 19字节

**2. 里程计数据 (下位机 → 上位机)**
- **STM32** → `serial_communication` → `serial_rx_data` → `wheel_odometry_node` → `/odom` + TF
- 协议: header=0x5A (Vision_Send_s), disp_x/disp_y(m), delta_theta(rad), timestamp, CRC16
- 根据 master_process.c，包含50ms积分后的位移数据

## 快速启动

### 1. 完整调试模式（推荐）

```bash
# Terminal 1: 启动串口调试系统
cd ~/slam
source install/setup.bash
ros2 launch navigation_control serial_debug.launch.py

# 包含:
# - serial_communication (串口收发)
# - serial_data_publisher (控制命令发送)
# - wheel_odometry_node (里程计解析)
# - serial_monitor (数据监控)
# - odom_to_path (轨迹显示)
# - RViz2 (可视化)
```

### 2. 键盘控制测试

```bash
# Terminal 2: 启动键盘控制
ros2 run navigation_control test_velocity_pub.py

# 按键:
# w/s - 前进/后退
# a/d - 左移/右移
# q/e - 逆时针/顺时针旋转
# space - 停止
```

### 3. 手动速度命令

```bash
# Terminal 2: 发布测试速度
# 前进 0.5m/s
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}"

# 左平移 0.3m/s
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.0, y: 0.3, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}"

# 旋转 1.0 rad/s
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.0}}"

# 停止
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}"
```

## 参数配置

### serial_debug.launch.py 参数

```bash
# 指定串口
ros2 launch navigation_control serial_debug.launch.py serial_port:=/dev/ttyUSB0

# 修改波特率
ros2 launch navigation_control serial_debug.launch.py baudrate:=921600

# 禁用 RViz（节省资源）
ros2 launch navigation_control serial_debug.launch.py use_rviz:=false

# 启用 CRC 校验（生产环境）
ros2 launch navigation_control serial_debug.launch.py enable_crc_check:=true
```

## 数据监控

### 查看话题列表

```bash
ros2 topic list

# 应该看到:
# /cmd_vel              - 速度命令输入
# /serial_tx_data       - 串口发送数据
# /serial_tx_hex        - 发送数据HEX显示
# /serial_rx_data       - 串口接收数据
# /serial_rx_hex        - 接收数据HEX显示
# /odom                 - 里程计输出
# /odom_path            - 轨迹路径
# /odom_debug_data      - 调试数据（9个float）
# /tf                   - TF变换
```

### 实时监控数据

```bash
# 监控速度命令
ros2 topic echo /cmd_vel

# 监控里程计
ros2 topic echo /odom

# 查看串口发送（HEX）
ros2 topic echo /serial_tx_hex

# 查看串口接收（HEX）
ros2 topic echo /serial_rx_hex

# 查看里程计调试数据
ros2 topic echo /odom_debug_data
# 9个值: 机器人坐标系delta_x/y/theta, 世界坐标系delta_x/y/theta, 累计x/y/theta
```

### 检查通信频率

```bash
# 控制命令频率（应该跟随 /cmd_vel）
ros2 topic hz /serial_tx_data

# 里程计数据频率（下位机50ms = 20Hz）
ros2 topic hz /serial_rx_data

# 里程计输出频率
ros2 topic hz /odom
```

### 检查TF树

```bash
# 查看TF变换
ros2 run tf2_tools view_frames

# 应该生成 frames.pdf，包含:
# odom -> base_link -> laser
```

## 故障排查

### 问题1: 串口打不开

```bash
# 检查设备
ls -l /dev/ttyUSB* /dev/stm32

# 修改权限
sudo chmod 666 /dev/ttyUSB0

# 或创建udev规则
sudo nano /etc/udev/rules.d/99-stm32.rules
# SUBSYSTEM=="tty", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="5740", SYMLINK+="stm32", MODE="0666"
sudo udevadm control --reload-rules
```

### 问题2: 收不到数据

```bash
# 检查串口节点是否运行
ros2 node list | grep serial

# 查看节点日志
ros2 node info /serial_communication

# 检查下位机是否发送
# - 下位机应该每50ms发送一次 Vision_Send_s
# - header 必须是 0x5A
# - 检查 master_process.c 中的 VisionSend() 是否被调用
```

### 问题3: 控制命令发不出去

```bash
# 检查发布器节点
ros2 node list | grep serial_data_publisher

# 查看是否有人订阅 /cmd_vel
ros2 topic info /cmd_vel

# 检查 serial_tx_data 是否有数据
ros2 topic hz /serial_tx_data
```

### 问题4: 里程计不准

```bash
# 查看原始数据
ros2 topic echo /odom_debug_data

# 检查:
# 1. delta值是否合理（米级）
# 2. 累计位姿是否连续
# 3. 角度变化是否正确

# 对比下位机日志:
# - 下位机发送的 disp_x/disp_y 应该是 50ms 内的累计位移（m）
# - delta_theta 应该是 50ms 内的累计角度变化（rad）
```

## 下位机协议对照

### master_process.c 发送的数据（Vision_Send_s）

```c
typedef struct {
    uint8_t header;           // 0x5A
    uint8_t detect_color;
    // ... 其他字段
    float disp_x;             // 50ms内X方向位移 (m)
    float disp_y;             // 50ms内Y方向位移 (m)
    float heading_diff;       // 运动方向角 (rad)
    uint32_t timestamp;       // 时间戳 (ms)
    uint16_t checksum;        // CRC16
} Vision_Send_s;
```

### shoot.c 接收的控制命令（预期）

下位机需要实现接收 19字节控制包:

```c
typedef struct {
    uint8_t header;        // 0xA5
    float vx;              // m/s
    float vy;              // m/s
    float wz;              // rad/s
    uint32_t timestamp;    // ms
    uint16_t checksum;     // CRC16
} OmniWheelCmd;
```

## 性能指标

- **控制延迟**: < 100ms (取决于 /cmd_vel 发布频率)
- **里程计频率**: 20Hz (下位机50ms窗口)
- **数据丢包率**: < 1% (CRC校验)
- **位置精度**: 取决于轮子打滑和标定

## 下一步集成

完成串口调试后，可以集成到导航系统:

1. **建图模式**: `mapping.launch.py` 已包含 `serial_data_publisher` 和 `wheel_odometry_node`
2. **导航模式**: `navigation.launch.py` 需要添加这两个节点
3. **定位模式**: Cartographer localization 可以融合轮式里程计提高精度

## 注意事项

⚠️ **坐标系一致性**
- 上位机发送: vx=前后, vy=左右, wz=逆时针为正
- 下位机接收: 必须匹配上述定义
- 下位机发送: disp_x/disp_y 在机器人坐标系
- 上位机接收: 转换到世界坐标系（odom frame）

⚠️ **时间戳**
- 上位机和下位机时间戳可能不同步
- 仅用于检测数据新鲜度，不做精确时间对齐

⚠️ **CRC校验**
- 调试时可关闭 `enable_crc_check:=false`
- 生产环境必须开启
- 下位机和上位机使用相同的CRC16算法
